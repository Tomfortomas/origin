//返回值优化：条件有二：首先函数签名的返回值与实际的返回值相同，第二返回的是局部变量的左值

//向上类型转换：只对public类型继承有效，并且是隐式转换，只要可以用父类的指针的地方都可以使用基类
//注意：向上类型转换可以使得重写隐藏无效化（此时派生类对象已经被切片，所以重写隐藏没了，无效化）
//以上所说的对象切片只对直接的对象的变化有效，而不是对指针或者引用，需要创建新对象
//假如是指针（引用）的向上类型转换（例如使用基类的指针指向一个父类），那么只保留基类的接口，此时原来的信息没有丢失
//编译器早捆绑：虽然用指针向上类型转换时没有发生对象切片，但调用函数时编译器已经默认调用的是基类的方法，因此重写隐藏依然无效
//函数调用捆绑：早捆绑和晚捆绑（动态捆绑和运行时捆绑）——晚捆绑只对虚函数起作用
//虚函数：virtual关键字声明（见课上ppt，可以调用Wind::play)，对基类的函数声明为虚函数，则可以实现晚捆绑（实现多态）
//若子类函数重写覆盖基类中的虚函数，则子类函数也为虚函数（重写覆盖时必须要名字与参数都相同）
//再次注意：晚绑定只对指针和引用有效

//VPTR类型：void*，有且仅有一个，指向虚函数表
//构造函数不能是虚函数，编译器在构造函数的开头插入一段初始化VPTR的代码
//基类的构造函数一定会调用本地的函数，不会晚捆绑

//但是析构函数可以是虚的，并且常常是虚的，这样可以根据指针所指对象的实际类型进行析构（所以最好将基类的析构函数写成虚函数）
//但是注意，虚机制在析构函数内部不工作
//override关键字可以对重写覆盖进行检查，但是只是检查，不是必要条件
//final关键字：确保虚函数不被派生类重写/在类定义中出现时，保证类不会被继承->class B final